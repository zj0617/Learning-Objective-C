## 对象

#### 方法和消息

OC中，如果需要执行方法里的代码，首先需要发送一条消息给包含这个方法的**类或者对象**；



#### 消息发送

消息发送指令必须写在一对方括号[ ]中，并且必须包含接收方和选择器

<img src="C:\Users\HP\Desktop\OC\截图\微信截图_20210323120908.png" style="zoom:50%;" />

date方法执行后，NSDate类会在堆上给NSDate实例声明一部分内存，将NSDate实例初始化为当前的日期/时间，然后返回新对象的地址。

[接收方 选择器/方法名]

接收方为类，选择器就为类方法；

接收方为实例，选择器就为实例方法；



#### 类方法和实例方法

类方法会创建类的实例，并初始化实例变量；

实例方法会提供实例中实例变量的信息，或是对实例的实例变量进行操作；



#### 大小写

OC是区分大小写的



#### OC语言的命名习惯

- 指向实例的变量使用“骆驼拼写法”来命名。以小写字母开头、接下来每一个单词的第一个字母使用大写，如:weightLifter

- 方法的命名也用骆驼拼写法；

- 类的名称以大写字母开头，但是接下来的单词继续使用骆驼拼写法；

  一般来说，类的名称是要加前缀的，这样可以避免相似的类名造成的混乱。通过前缀还可以知道它属于哪一个框架。Foundation框架使用NS前缀；



## 消息

#### 传递实参的消息

方法和函数类似，可以没有实参，也可以有一个或多个实参；

方法名:实参

方法名带有实参的时候，冒号是构成方法名的一个重要部分；



#### 多个实参

<img src="C:\Users\HP\Desktop\OC\截图\微信截图_20210323122958.png" style="zoom:50%;" />

<img src="C:\Users\HP\Desktop\OC\截图\微信截图_20210323123003.png" style="zoom:50%;" />

写成三行是允许的；

编写消息发送代码，通常会对齐冒号；



#### 消息的嵌套发送

消息可以以嵌套的形式连续发送

![](C:\Users\HP\Desktop\OC\截图\微信截图_20210323123315.png)

嵌套发送的消息，系统会先执行最里面的消息，然后由内向外的顺序依次执行外层的消息。



#### alloc和init

**唯一必须以嵌套的形式连续发送的消息是alloc和init**。

每个类都有一个**alloc类方法**，它能够**创建一个新的对象，并且返回指向该对象的指针**。

通过alloc创建出来的对象，必须经过初始化才能使用，未初始化则无法接受消息；

每个类也都有一个**init实例方法**，它用来**初始化实例**。



#### 向nil发送消息

nil:不指向任何对象的指针，在OC中nil是值为0的指针；

OC中可以向nil发送消息，什么事情都不会发生；

- 如果程序向某个对象发送了消息，却没有得到预期的结果，请检查消息接收方是否为nil；
- 向nil发送消息得到的返回值没有意义；



#### id

id类型的含义：可以指向**任意类型OC对象的指针**；

id已经隐含了星号的作用；



## 对象与内存

#### 指针和指针的值

指针和它指向的对象是不同的；

指针变量保存的是类实例在内存中的地址；

创建对象是在堆上分配内存；



#### 内存管理

栈是由有序的帧构成的，函数的帧在函数结束后会自动释放，而堆里的对象不会自动释放。

每个对象被创建和都会占用一定的堆内存；



#### ARC

自动销毁不被引用的对象的机制称为ARC（自动引用计数）。（引用是指针的另一种叫法）：每个对象都会对指向自己的指针进行计数，**当引用数为0时，就会认为不需要该对象了，程序会自动销毁该对象**。

只要有一个指针指向对象，这个对象就会继续存在。

申请缓冲区，调用free()函数来销毁对象是清理得最干净得方法。

如果不再需要某个对象，则可以将指向它的指针设置为nil，或者销毁他的指针。



## NSString

#### 创建NSString实例

**字面量语法：**

@"……"代表根据给定的字符串创建一个NSString对象。

上述创建的实例称为NSString的字面量实例，或者称为NSString字面量。

NSString实例可以保存任意Unicode字符，如果需要插入非ASCII码字符，则可以使用\u，后面加上该字符的十六进制Unicode编码。

![](C:\Users\HP\Desktop\OC\截图\微信截图_20210324174836.png)

**创建动态字符串：**

**stringWithFormat：类方法**来创建动态字符串（不清楚内容的字符串，需要等到程序运行的时候才能知道）

stringWithFormat：方法后面跟着**一个格式字符串作为参数**，这个格式字符串带有一个格式说明符和一个变量，变量的值会被用来替换格式说明符。



#### NSString方法

类方法的声明开头是“+”；

实例方法的声明开头是“-”；

**常用方法：**

- **-（NSUInteger）length**

  获取字符串中字符的数量；

  NSUInteger为无符号长整型；

- **-（BOOL）isEqualToString:(NSString *)other**

  判断一个字符串是否和另一个字符串相等

- **-（NSString*）uppercaseString**

  把一个字符串变成大写形式

- **-（NSRange）rangeOfString:(NSString*)aString**

  查找一个字符串是否包含某一个字串，返回NSRange结构体含location和length，找不到返回的NSRange的location是NSNotFound。

  区分大小写

- **-（BOOL）localizedCaseInsensitiveContainsString:(NSString *)str**

  不区分大小写；

  查看一个字符串是否包含另一个字符串；

  返回值为BOOL类型；



#### 类参考

Xcode->Documentation and API Reference可以参考一个类的所有方法。

developer.apple.com查看，参考实现某个功能的方法



## NSArray

NSArray实例可以保存**一组指向其他对象（可以是不同类的对象）**的指针；



#### 创建数组

NSArray也可以**用字面量语法创建实例**。数组的内容写在方括号内，用逗号分隔，前方带有@符号，不必发送创建实例的消息。

**NSArray的实例是无法改变的**，一旦NSArray实例被创建后，就无法添加或者删除数组里的指针，也无法改变数组里的指针顺序。



#### 存取数组

NSArray中的指针是有序排列的，并且可以通过相应的索引来存取，索引从0开始；

数组名[索引]可以存取某个数组的指针；

**-（NSUInteger)count**

返回NSArray对象所含指针的个数



#### 遍历数组

使用for循环来遍历数组；

简化的for循环语法—快速枚举

```objective-c
for(NSDate * d in dataList)
{
    NSLog(@"%@",d);//dataList为NSArray实例
}
```



#### NSMutableArray

和NSArray类似，但是可以添加、删除或者对指针重新排序（NSMutableArray是NSArray的子类）；

- **array类方法**

  创建NSMutableArray，返回一个而空数组；

  和使用alloc和init一样的效果

- **addObject:实例方法**

  给NSMutableArray添加对象，在尾部添加；

- **insertObject:atIndex:实例方法**

  将对象添加到一个特定的索引上；

- **removeObjectAtIndex:实例方法**

  删除数组中特定索引上的对象；

**注意：**快速枚举遍历NSMutableArray时，不能再枚举过程中增加或者删除数组中的指针。如果遍历时候需要添加或者删除指针，需要使用标准for循环；



#### 旧式数组方法

arrayWithObjects：类方法来创建NSArray实例；

要用nil作为结束标记，告诉方法停止运行；

objectAtIndex:实例方法访问数组中的指针；



## 自定义类

任何一个类都可以通过以下两种途径描述对象：类实例所包含的实例变量和类的方法。

头文件.h（header）或接口文件（interface file）包含实例变量和方法的声明；

实现文件.m（implementation file）包含所有方法的代码实现；

头文件以@interface 开始，@end 结束，注意要在花括号内声明实例变量。按照惯例，实例变量的名字是以下划线"_"开始的。

在花括号外声明实例方法；

实现文件以@implementation开始，@end结束；



#### 存取方法

存取对象的实例变量的方法：存方法、取方法；

**命名规范：**

取方法的名字和相应的实例变量一样，但要去掉下划线；

存方法以set开头，后面跟上去掉下划线的实例变量名（骆驼拼写法）；



#### self

OC的方法都包含一个隐含的局部变量self；

self是指针，**指向运行当前方法的对象**；

当某个对象要向自己发送消息时，就需要使用self；

还可以将self作为实参传递给其他方法，以便访问当前的对象；



#### 多个实现文件

多个.m文件，.h文件；Xcode在构建程序时，会将每个.m文件和.h文件编译成机器码，然后将它们和库连接在一起编成可执行的文件。



#### 类前缀

OC没有命名空间；

为了避免名字冲突，推荐使用三个及以上个字母作为类的前缀，让类的名字独一无二；



## 属性

#### 声明属性

属性的声明以@property开始，然后是属性的类型和名称。声明属性的时候，编译器不仅会帮我们声明存取方法，还会根据属性的声明实现存取方法。编译器自动会产生基于属性的实例变量！



#### 属性的特性

属性的声明可以有一个或者多个属性特性。属性特性显示在@property接口后的括号中；

- 属性要么是原子性的（atomic），要么是非原子性的。区别和多线程有关，默认为原子性；

- 只读（readonly）属性，指该属性的值只能读取，不能改写，这样的属性需要拥有取方法而不能有存方法。

  属性要么是只读属性，要么就是读/写（readwrite）属性，默认为读写属性。

- 可拷贝（copy）



#### 用点号调用存取方法

使用点号可以调用存取方法，但记住，**使用点号是在发送消息**；





## 继承



#### 覆盖方法

子类继承父类，子类可以覆盖方法（更改方法的实现）。

覆盖方法的时候只能改变方法的实现，而无法改变它的声明方式、方法的名称、返回类型以及实参类型等都必须保持相同；子类继承的父类的方法，在子类的声明中中无需再声明！



#### Super

super：指向父类的指针。在覆盖一个方法的时候，子类可以利用父类的实现，而不是要整个替换。



#### 继承层次

![](C:\Users\HP\Desktop\OC\截图\微信截图_20210326203638.png)

NSObject虽然拥有很多方法，但只有一个实例变量：isa指针。任何一个对象的isa指针都会**指向创建该对象的类**；

![](C:\Users\HP\Desktop\OC\截图\微信截图_20210326203705.png)

给某个对象发送消息时，收到消息的对象会通过isa指针沿着继承链向上找并查询是否存在该消息名对应的方法，直到到达继承链的顶端。如果没有找到，程序就会报错；若有，程序会执行首先找到的方法。

但如果使用super指令，就等于告诉对象，“运行指定的方法，但是要从对象的父类开始查找与之匹配的实现”；



#### description方法和%@转换说明

![](C:\Users\HP\Desktop\OC\截图\微信截图_20210326204728.png)





## 对象实例变量及属性

对象实例变量的三种常见用途：推荐声明为属性！

1、对象属性：指针，指向某一个单一的、代表某个值的对象；

2、一对一关系：指针，指向单个复杂的对象；

3、一对多关系：指针，指向某个collection类的实例；

任何一个对象不会在其内部保存其他对象，只有可能在内部保存相应对象的地址。

这种指向其他对象的特性会产生两大副作用：

1、单个对象可能会扮演多个角色；

2、导致产生大量独立的对象，耗尽程序的可用内存；



#### 对象所有权与ARC

当某个对象A拥有某个对象实例变量B时，称A拥有B指向的对象。

ARC自动引用计数，任何一个对象都知道自己当前由多少个拥有方。当某个对象的拥有方个数变为0时，可以判定程序不再需要该对象，从而释放该对象。

当某个对象没有拥有方时，就会被释放掉。有一个NSObject方法称为dealloc，如果类覆盖了dealloc，那么当类的实例被释放时，就会执行dealloc方法。



#### 一对多关系

当collection类的对象加入某个对象时，会保存指向该对象的指针，并且称为该对象的拥有方；当collection类对象移除某个对象时，会删除指向该对象的指针，并不再是该对象的拥有方。



如果程序有用不到的但又没有被释放的对象，就称程序有**内存泄漏**。





## 类扩展

并不是所有的属性或者方法都需要在类的头文件中声明。有的属性或者方法只是该类或者其类实例才需要使用的。

涉及实现细节的属性或者方法最好在类扩展中声明。类扩展是一组私有的声明，只有类和其类实例才能使用在类扩展中声明的属性、实例变量或者方法。

通常，类扩展是添加在类实现文件中的，实现方法的@implementation之上的。

类扩展以@interface开始，@end结束。实际上，类扩展和头文件看上去很像。然而，在类扩展中，和头文件使用冒号和父类的名称不同，它使用的是一对空括号。

在类扩展中声明的实例变量、属性或者方法，非类实例是不可见的，也就是说无法获取到。



#### 隐藏可变属性

将不可见的属性或者方法在类扩展中声明。



#### 头文件与继承

子类无法获取父类的类扩展。



#### 头文件与生成的实例变量

在类的头文件.h中声明属性的时候，其他对象**只能看到属性的存取方法**。非类对象（包括其子类）无法直接获取属性声明生成的实例变量。



## 避免内存泄漏

#### 强引用循环

“互相拥有”的所有权关系导致相关的对象都无法被释放。

强引用循环是导致内存泄漏的常见原因。



#### 弱引用

通过弱引用可以解决强引用循环问题。弱引用是不说明所有权的指针。即在属性特性中加上weak！

如果对象间是父子关系，那么为了避免强引用循环，通常需要遵守此规则：父对象拥有子对象，但子对象不拥有父对象。



#### 弱引用的自动置零特性

当某个弱引用指向的对象被释放时，相应的指针变量会归零，即被赋为nil。



#### 强引用和弱引用

强引用会保留对象的拥有权，使其不被释放。而弱引用则不会保留，因此被标为弱引用的实例变量与属性指向的对象可能会消失。如果发生了这种情况，那么这个实例变量或者属性会被设为nil，而不是继续指向曾经指向的对象。





## Collection类

collection类的实例用于保存**指向其他对象（可以是不同类的对象）**的指针。

NSArray/NSMutableArray、NSSet/NSMutableSet、NSDictionary/NSMutableDictionary



#### NSSet/NSMutableSet

NSSet对象所包含的内容是**无序**的，而且在一个NSSet对象中，某个特定的对象只能出现一次。

NSSet对象的最大用处是检查某个对象是否存在。

NSSet对象也分为可对指针进行修改和不可对指针进行修改两类：NSSet对象是不能对指针进行修改的—对象创建好后就不能对其中的指针进行添加或删除等操作。而NSMutableSet是它的子类，它能够对其中的指针进行添加或者删除等操作。

NSSet对象中的**对象是无序的，所以不能通过索引来访问，**只能够向NSSet对象查询某个对象是否存在，可以使用下面的方法进行查询：

```objective-c
- (BOOL) containsObject:(id)x;
```

**区分相同和相等的概念**

相同的变量一定是相等的，而相等的变量不一定是相同的。

例如NSMutableArray中的两个方法：

![](C:\Users\HP\Desktop\OC\截图\微信截图_20210329214736.png)



#### NSDictionary/NSMutableDictionary

NSDictionary是一组**键值对**的集合。**键通常是字符串，值可以是任意类型的对象**。字典对象以键位索引：给出键，就可以得到和键相关联的值（一个任意类型的对象）。**字典对象中的键都是独一无二的，字典对象的键值对是无序的**

NSDictionary也有一种创建不可更改的字典的快捷方式。字典的字面量由@和花括号组成，在花括号中填上由逗号分隔的键值对，键值对之间由冒号分隔。

**字典里的键是独一无二的**，如果想要在现存的键后再添加第二个对象，第一个键值对就会被替换。

NSMutableDictionary可以用类方法dictionary创建；

添加对象的实例方法：

setObject:(id)x atKey:(NSString*)str



#### 不可修改对象

使用不能修改的collection可以节约内存提高性能，因为它永远无需拷贝。而对于可修改对象，则可能发生这样的一种情况：程序中的其他代码可能在你使用这个可修改对象的时候修改它的内容。为了避免这个情况的发生，就需要复制一份私有的拷贝。

NSArray的copy方法不会做任何额外的事情，仅仅返回指向自身的指针。而NSMutableArray的copy方法则会制作一份自己的拷贝，并且返回指向新数组对象的指针。

**注意：NSDate和NSNumber只有不可修改的版本。**



#### 数组排序

不可修改的数组NSArray不能排序。

NSMutableArray可以用如下实例方法对于数组进行排序：

```objective-c
- (void)sortUsingDescriptors:(NSArray*)sortDescriptors;
```

该方法的实参是一个包含NSSortDescriptors对象的数组对象。排序描述对象包含两个信息：一是数组中对象的属性名，二是根据该属性是要升序还是降序。

![](C:\Users\HP\Desktop\OC\截图\微信截图_20210403222913.png)

为什么要传入一组NSSortDescriptors对象？因为可能对于第一个排序描述对象的属性取值相同，那么就需要按照第二个排序描述对象的属性排序。



#### 过滤

对于collection进行过滤的时候，程序将对collection对象和一条逻辑语句进行比较，得到一个合成的collection，这个collection只包含满足这条语句的对象。

Foundation中有一个名为**NSPredicate**的类。NSPredicate对象可以包含一条语句，其运算结果可以为“真”或者“假”。NSMutableArray有一个名为**filterUsingPredicate:**的方法，通过该方法可以很方便地删除所有不能满足传入的NSPredicate对象的对象。

NSArray有一个名为**filteredArrayUsingPredicate：**的方法，可以创建一个新的数组，包含所有能够满足传入的NSPredicate对象的对象。

```objective-c
- (NSArray*)filteredArrayUsingPredicate:(NSPredicate*)predicate
```

NSSet也有一个方法可以用于过滤：

```objective-c
- (NSSet *)filteredSetUsingPredicate:(NSPredicate *)predicate
```

NSMutableSet也有：

```objective-c
- (void)filterUsingPredicate:(NSPredicate *)predicate
```



#### Collection对象与所有权

向collection对象中加入某个对象时，collection对象会成为该对象的拥有方；如果从collection对象中移除该对象，那么collection对象就不再是该对象的拥有方了。



#### C语言基本类型

collection对象只能保存对象，如果要保存float、int变量或者指向结构的指针，可以先将这些C语言基本类型封装成对象。

可以使用@创建一个NSNumber字面量实例；

需要注意：不能直接使用NSNumbewr对象进行计算，只能先使用一个NSNumber方法提取其基础值进行计算。

而对于结构，可以使用一个封装的类实例—NSValue（它是NSNumber的父类）来保存指针和部分特定的结构类型。

例如NSPoint（可以保存坐标的x值和y值）可以使用NSValue封装。

NSValue可以保存任意的数量值！



#### Collection对象与nil

之前介绍的collection对象都不能保存nil。如果要将nil加入collection对象，则可以使用NSNull类。NSNull类只有一个实例，代表空。

```objective-c
[NSNull null];//创建NSNull实例
```



## 常量

在OC中，通常可以通过两种途径来定义常量：#define和全局变量。



#### #include和#import

作用类似：都是先要求预处理器读取某个文件，然后将读入的内容添加至输出结果。

差别：

1、#import会确保预处理器只导入特定的文件一次；

2、#include则允许多次导入同一个文件；

加上双引号或者尖括号：如果是双引号，那么编译器会在项目目录下查找相应的头文件；如果是尖括号，那么编译器会在预先设定好的标准目录下查找相应的头文件。



#### #define

#define A B：告诉预处理器，在编译器看到A之前，使用B替代之。

除了可以定义常量，还可以使用#define构建类似函数的代码段—宏。



#### 全局变量

编写OC程序时，通常不是使用#define来保存常量，而是使用全局变量来完成这项任务。



#### enum

枚举类型；通常情况下，枚举常量所代表的数字不会有实际的意义—其作用仅仅是为了能够区分不同的常量。

![](C:\Users\HP\Desktop\OC\截图\微信截图_20210405221045.png)

![](C:\Users\HP\Desktop\OC\截图\微信截图_20210405221108.png)



#### 比较#define与全局变量

使用全局变量的效率更高；算术运算快于消息发送。

因此在定义常量时，应该使用全局变量和enum，而不是#define。





## 通过NSString和NSData将数据写入文件

#### 将NSString对象写入文件

在将字符串对象写入文件时，需要指定**字符串编码**。

UTF编码支持几乎所有的语言，UTF分为UTF-8和UTF-16。多数情况下，UTF-8是一个不错的选择。

writeToFile:(NSString *) path 

atomically:(BOOL)

encoding:

error:

文件路径可以是绝对的或者是相对的：绝对路径是以/开头（/代表文件系统的根目录），而相对路径则是相对于程序当前的工作目录，不会以/开头，通常使用绝对路径。



#### NSError

通过**引用**传入的NSError参数，按引用传递仍然是加上&；

NSS同日那个的writeToFile：atomically：encoding：error：的方法声明如下：

```
- (BOOL)writeToFile:(NSString *)path
		atomically:(BOOL)useAuxiliaryFile
		encoding:(NSString *)enc
		error:(NSError **)error
```

**双星号**代表相应的参数是一个地址，该地址处存放了指向某个对象的指针。



#### 通过NSString读取文件

![](C:\Users\HP\Desktop\OC\截图\微信截图_20210406215355.png)



#### 将NSData对象所保存的数据写入文件

NSData对象代表内存中的某块缓冲区，可以保存相应字节数的数据。

![](C:\Users\HP\Desktop\OC\截图\微信截图_20210406215722.png)

writeToFile：options：error：在保存数据时所使用的设置要通过options参数传入。最常见的设置就是使用NSDataWritingAtomic—具备原子性的写操作，NSData对象会将数据先写入临时文件，成功后再移动至指定路径，这样，程序要么成功生成一个完整的文件，要么什么都没有。



#### 从文件读取数据并存入NSData对象

![](C:\Users\HP\Desktop\OC\截图\微信截图_20210406220125.png)



#### 寻找特别目录

![](C:\Users\HP\Desktop\OC\截图\微信截图_20210406220257.png)



## 回调

**回调（callback）**是**将一段可执行代码和一个特定的事件绑定起来，当特定的事件发生时，就会执行这段代码**。

在OC中，有四种途径可以实现回调：

1、**目标-动作对（target-action）**：在程序开始等待前，要求“当事件发生时，向指定的对象发送某个特定的消息”。接收消息的对象是目标（target），消息的选择器（selector）是动作。

2、**辅助对象（helper objects）**：在程序开始等待前，要求“当事件发生时，向遵守相应协议的辅助对象发送消息”。委托对象（delegate）和数据源（data source）是常见的辅助对象。

3、**通知（notification）**：通知中心对象，在程序开始等待前，可以告知通知中心“某个对象正在等待某些特定的通知。当其中的某个通知出现时，向指定的对象发送特定的消息”。当事件发生时，相关的对象会向通知中心发布通知，然后再由通知中心将通知转发给正在等待该通知的对象。

4、**Block对象（Blocks）**：Block时一段可执行的代码，在程序开始等待前，声明一个Block对象，当事件发生时，执行这段Block对象。



#### 运行循环

事件驱动的程序需要有一个对象，专门负责等待事件的发生。有一个叫**NSRunLoop**的类（运行循环）。NSRunLoop实例会持续等待着，当特定的事件发生时，就会向相应的对象发送消息。NSRunLoop实例会在特定的事件发生时触发回调。

[NSRunLoop currentRunLoop]—创建NSRunLoop实例

run—实例方法，让NSRunLoop实例运行开始等待。



#### 目标-动作对

**NSTimer计时器**使用的是目标-动作对机制。

创建计时器时，要设定延迟、目标和动作。

在指定延迟时间后，计时器会**向设定的目标发送指定的消息**。

动作方法总是有一个实参指向发送动作消息的那个对象

![](C:\Users\HP\Desktop\OC\截图\微信截图_20210406222645.png)

使用@selector语句来传递动作消息的名称给相应的方法，这里需要传递相应的实参，不能只传递方法的名字。

很多简单的用户界面控件（例如按钮和滑块）都是采用目标-动作对机制。



#### 辅助对象

例子：采用异步方式来使用NSURLConnection，在异步模式下，NSURLConnection不会一次发送完全部数据，它会发送块状数据，并且多次发送。也就是说，需要有传输相关的事件，而且程序需要做好准备响应这个事件。

**当特定的事件发生时，该对象会向辅助对象发送相应的消息**。**协议是一系列的方法声明**，辅助对象可以根据协议实现相应的方法。

然后我们需要**在委托对象中实现响应特定事件的回调方法**。

需要在委托对象中声明其会实现的协议方法：

![](C:\Users\HP\Desktop\OC\截图\微信截图_20210407081618.png)

除此之外需要创建一个实例变量保存来自服务器的数据，由于是异步按快传输，因此需要使用NSMutableData。

另外还需要在委托对象的.m文件中实现其对应的协议方法，其实就是委托对象在事件发生时会收到的来自于对象的消息。

**总结**：当需要向一个对象发送一个回调时，会使用目标动作对；当要向一个对象发送多个回调时，会使用符合相关协议的辅助对象。



#### 通知

要向多个对象发送回调时！

需要接收消息的对象可以通过通知中心将自己注册为**观察者（observer）**。

当特定事件发生时，会向通知中心发送相应通知，通知中心再将该通知转发给相应的观察者。

创建一个通知中心，并添加观察者：

![](C:\Users\HP\Desktop\OC\截图\微信截图_20210407082533.png)

向通知中心注册观察者时，你可以指定某个特定的通知名（name）以及通知发布的来源（object），这两个参数你可以设置为nil，但此时，观察者就会接收到程序中所有对象发送的所有通知。



#### 如何选择

针对上述三种类型的回调：

1、对于只做一件事情的对象（例如：NSTimer），使用目标-动作对；

2、对于功能更加复杂的对象（例如：NSURLConnection），使用辅助对象。最常见的辅助对象就是委托对象；

3、对于要触发多个（其他对象中的）回调的对象（例如NSTimeZone），使用通知；

![](C:\Users\HP\Desktop\OC\截图\微信截图_20210407170355.png)



#### 选择器的工作机制

当某个对象收到消息时，会使用isa指针向创建该对象的类进行查询，检查是否有与消息名称相匹配的方法，该查询过程会沿着继承层次结构向上，直到某个类回应“我有与消息名称相匹配的方法”。

方法的查询非常快速，但是如果使用方法的实际名称（可能很长）进行查询，那么查询速度会很慢。为了提速，**编译器会为每个其接触过的方法附上一个唯一的数字。运行时，程序使用的是这个数字，而不是方法名。**

**代表特定方法名的唯一数字称为选择器（selector）**

当一个方法需要一个选择器作为实参时，它实际需要的是这个数字，此时通过编译指令@selector（xxx），可以得到与方法名相对应的选择器。



#### 回调与对象所有权

常常会发生这种情况：创建的对象拥有一个指向回调对象的指针（回调对象：触发回调的对象，即发送消息、协议或者通知的对象），而这个回调对象的指针指向你创建的对象。他们彼此之间具有强引用关系，最后会陷入一个强引用循环，这两个对象都无法释放。

所以在编写代码时，需要遵守以下规则：

- **通知中心不拥有观察者**

  如果将某个对象注册为观察者，那么通常应该在释放该对象时将其移出通知中心。

  removeObserver：(id)

- **对象不拥有委托对象或者数据源对象**

  如果某个新创建的对象是另一个对象的委托对象或者数据源对象，那么该对象（**指的是回调对象**）应该在其dealloc方法中取消相应的关联。

  setDelegate:nil

  setDataSource:nil

- **对象不拥有目标**

  如果某个新创建的对象是另一个对象的目标，那么该对象（**指的是回调对象**）应该在其dealloc方法中将相应的目标指针赋值为nil。

  setTarget:nil

  

  

## Block对象

Block对象就是一段代码。

是在一对花括号内的一套指令，但是它没有函数名，相应的位置只有一个^符号，^符号表示这段代码是一个Block对象。

和函数一样，Block对象也可以有实参和返回值：

![](C:\Users\HP\Desktop\OC\截图\微信截图_20210407090805.png)

Block对象还可以被当成一个实参传递给可以接收Block的方法。



#### 使用Block对象

- **声明Block变量**

  Block对象可以用变量保存。

  ![](C:\Users\HP\Desktop\OC\截图\微信截图_20210407091355.png)

  Block变量的名字写在括号中—devowelizer，跟在^符号后面。

  Block的声明需要包括Block的返回类型（void）以及它的实参类型（id，NSUInteger，BOOL*）

  说明Block变量是什么类型时，需注意它不是一个简单的“block”，它的类型包含实参、返回值的说明。

- **编写Block对象**

  ![](C:\Users\HP\Desktop\OC\截图\微信截图_20210407091844.png)

  Block变量的赋值也需要以分号结束。此外，和其他变量一样，也可以将Block变量的声明和赋值写在一起：

  ![](C:\Users\HP\Desktop\OC\截图\微信截图_20210407092003.png)

- **传递Block对象**

  ![](C:\Users\HP\Desktop\OC\截图\微信截图_20210407092229.png)

  enumerateObjectsUsingBlock:方法要求传入的Block对象的三个实参类型时固定的。第一个实参是对象指针，指向当前（枚举）的对象，该指针的类型是id，所以无论数组包含的是什么类型的对象，都可以将枚举对象的地址赋值给该指针；第二个实参的类型是NSUInteger，其值是当前对象在数组中的索引。第三个实参是指向BOOL变量的指针，该变量的默认值是NO，如果设置为YES，那么数组对象会在执行完当前的Block对象后终止枚举过程。

- **typedef**

  可以将Block对象类型定义为一个新类型，以方便使用。

  需要注意地是，不能在方法的实现代码中使用typedef，也即，应该在实现文件的顶部，或者头文件内使用typedef。

  ![](C:\Users\HP\Desktop\OC\截图\微信截图_20210407093006.png)

  这段代码看上去和Block变量的声明很像，但是，这里定义的是一个**新的类型**，而不是一个变量。跟在^字符后面的是类型名称。

  创建了新的类型之后，可以简化Block变量的声明。

  ![](C:\Users\HP\Desktop\OC\截图\微信截图_20210407093247.png)

  

#### Block对象 vs. 其他回调

之前学的两种回调机制：委托机制（delegation）和通知机制（notifications）。有一个缺点：即回调的设置代码和回调方法的具体实现无法写在同一段代码中，而且这两段代码经常会间隔很远，甚至出现在不同的文件中。

通过回调机制，程序能够在特定事件发生时调用指定方法。

通过Block对象，可以将与回调相关的代码写在同一代码段中。

**NSNotificationCenter**有一个方法：**addObserverForName：object：queue：usingBlock：**。这个方法和**addObserver：selector：name：object：**类似，但是它可以使用Block对象作为实参，而不使用选择器。



#### 深入学习Block对象

- **返回值**

  对于有返回值的Block对象，可以像调用函数那样调用Block对象，然后使用其返回值：

  ![](C:\Users\HP\Desktop\OC\截图\微信截图_20210407104527.png)

- **调用Block**

  像函数一样调用即可！

- **匿名Block对象**

  匿名Block对象是可以传递给方法的Block对象，而不需要先将Block对象赋值给变量。

- **外部变量**

  Block对象通常会在其代码中使用外部创建的其他变量（基本类型的变量，或者是指向其他对象的指针）。这些外部创建的变量叫做外部变量（external variables）。当执行Block对象是，为了确保其下的外部变量能够始终存在，相应的Block对象会**捕获**这些变量。

  对于基本类型的变量，捕获意味着程序会拷贝变量的值，并且用Block对象内的局部变量保存。对指针类型的变量，Block对象会使用**强引用**。这意味着凡是Block对象用到的对象，都会被保留。所以在相应的Block对象被释放前，这些对象一定不会被释放（这也是**Block对象和函数的差别**，函数无法做到这点）。

- **在Block对象中使用self**

  如果需要写一个使用self的Block对象，需要多做几步工作，避免造成强引用循环。

  为了打破这种强引用循环，可以先在Block对象外部声明一个_weak指针，然后将这个指针指向Block对象使用的self，最后在Block对象中使用这个新的指针。

  然而，由于是**弱引用指针**，因此self指向的对象有可能会在Block执行的过程中被释放，为了避免这种情况的发生，可以在Block对象内创建一个**对self的局部强引用**：

  ![](C:\Users\HP\Desktop\OC\截图\微信截图_20210407111133.png)

  通过创建innerSelf强引用，就可以在Block和BNREmployee实例中再次创建一个强引用循环，不过由于innerSelf引用是针对Block内部的，所以只有在Block执行的时候它才会执行，而Block结束后就会自动消失。

- **在Block对象中无意使用self**

  如果直接在Block对象中使用实例变量，那么Block会捕获self，而不会捕获实例变量。

  怎么解决？不要直接存取实例变量，使用存取方法！（dot标记可用）

- **修改外部变量**

  在Block对象中，被捕获的变量是常数，程序无法修改变量所保存的值。

  如果需要在Block对象中修改某个外部变量，则可以在声明相应的外部变量时，在前面加上**_block**关键字。



**回调的四种途径中使用Block对象的例子：**

- **使用通知机制**

  NSNotificationCenter的addObserverForName：object：queue：usingBlock：方法要求传入一个Block对象。当特定的通知发生时，通知中心就会执行这个Block对象，而不是与观察者打交道！对于传入这个方法的Block对象，需要有一个参数（类型为NSNotification*），并且没有返回值！

- **不用通知机制**

  ![](C:\Users\HP\Desktop\OC\截图\微信截图_20210407180140.png)

  ![](C:\Users\HP\Desktop\OC\截图\微信截图_20210407180148.png)



## 协议

有些类能够在不同的应用中扮演各种不同的角色，因此这些类的实例可以有多种不同的用法。

例如IOS常用UITableView实例来显示数据，但是UITableView本身并不包含要显示的数据，必须从辅助对象处获取。因此，程序必须告诉UITableView对象：这是你要的对象，这个对象将扮演数据源的角色。

![](C:\Users\HP\Desktop\OC\截图\微信截图_20210408222516.png)



协议可以为一个对象指定角色。

协议是一组方法声明，其中的部分方法是必需的，另一些是可选的。如果某个对象要扮演特定的角色，就一定要实现相应的必须方法（required method），并选择实现部分可选方法（optional method）。

UITableView的数据源协议是UITableViewDataSource。协议的声明方法如下：

<img src="C:\Users\HP\Desktop\OC\截图\微信截图_20210408222801.png"  />

![](C:\Users\HP\Desktop\OC\截图\微信截图_20210408223024.png)

如果某个类要遵守多个协议，则可以将这些协议以逗号分隔，一起写在尖括号里。

#### 调用可选方法

调用没有实现的可选方法，程序会崩溃。

因此可以在调用前使用respondsToSelector：询问对象是否实现里某个方法。这个方法在NSObject实现了，所以可以给程序中的任意对象发送此消息询问，返回值为BOOL型。





## Property List格式

property list文件可以由以下对象组成：NSArray、NSDictionary、NSString、NSData、NSDate、NSNumber（整数、浮点数或布尔值）。

property list方便写入文件writeToFile：。XML格式的文件。



## 第一个IOS应用

Cocoa是一组由苹果公司提供的框架，可以用来编写Mac应用，包含Foudation；

编写IOS应用需要用到另一组框架，称为Cocoa Touch。



#### 基于图形用户界面的应用（GUI）

图形用户界面（GUI）；

基于图形用户界面的应用是由**事件驱动**的。它会在程序运行后启动一个**运行循环（run loop）**，然后等待事件的发生。这些事件可以是用户生成的（比如按下按钮），也可以是系统生成的（比如内存过低警告）。

当事件发生时，应用就会采取行动，然后调用方法、发送消息等。所有IOS应用都是事件驱动的应用。



#### AppDelegate

应用程序委托，是程序的起点，每个IOS应用都有一个应用程序委托。

UIKit框架包含了大部分IOS特有的类，比如UITableView、UITextField、UIButton。AppDelegate遵循UIApplicationDelegate协议。

AppDelegate还包含一个指向UIWindow实例的属性，UIWindow对象构成IOS应用的屏幕。可以增加其他的对象到UIWindow上来创建应用的用户界面。

UITableView—表格视图；

UITextField—输入框；

UIButton—按钮；



#### Model-View-Controller

MVC（模型-视图-控制器）是一种设计模式，核心理念是：**开发程序时所创建的类、都应该可以归为模型、试图或者控制器三种类型**。

- **模型**

  模型负责保存数据，并且能够让其他对象访问这些数据。模型不处理用户界面，模型唯一需要完成的任务是**保存并管理数据**。

- **视图**

  视图是应用中的可见元素，知道如何在屏幕中画出自己，并响应用户输入。视图和显示的数据没有直接的关联，也不负责数据的保存和管理。UIView对象和众多的UIView子类（比如UIWindow）都是常见的视图对象。

  能够看见的对象就是视图对象。

- **控制器**

  控制器负责**执行程序的逻辑功能，以连接和驱动应用的不同组成部分**。控制器可以处理事件，并能与应用中的其他对象协同工作。

  模型对象和视图对象之间没有直接关联，需要控制器从中协调。控制器会接收发自某些对象的消息，然后将相应的指令转发给其他对象。

  ![](C:\Users\HP\Desktop\OC\截图\微信截图_20210412125755.png)



#### 应用委托对象

IOS应用启动时，程序会创建一个UIApplication实例，UIApplication实例是应用和操作系统之间的联络人，程序会创建一个AppDelegate实例，并且将其设置为**UIApplication实例的委托对象**。

应用委托回调方法：

```objective-c
- (BOOL)application:(UIApplication*)application
didFinishLauchingWithOptions:(NSDictionary*)lauchoptions
```

这个方法非常重要，在启动时，应用是无法工作或者接收输入的。启动完成后，UIApplication实例会向其委托对象发送application：didFinishLauchingWithOptions:消息。凡是需要**在程序能够和用户交互前就完成的初始化工作**，都应该在此方法中实现。



#### 设置视图

应用完成之前还需要设置相应的视图对象，包括：输入栏、按钮、表格视图。也就是说，要创建视图对象、设置属性并将视图放上窗口。

因此需要在application：didFinishLauchingWithOptions:方法中以代码的形式设置视图对象。

大致流程如下：

1、首先，创建所有的对象，并进行相应的设置（为对象的部分属性赋值）；

2、接着，将设置过的视图对象加入UIWindow对象，成为其下的**子视图**（subview）；addSubview:

3、最后将UIWindow放上屏幕；

![](C:\Users\HP\Desktop\OC\截图\微信截图_20210412131339.png)

![](C:\Users\HP\Desktop\OC\截图\微信图片_20210412191402.jpg)

**记得要给window的rootViewController赋值！**

设置UIWindow的根控制器，程序会自动将rootViewController的view添加到window中。

![](C:\Users\HP\Desktop\OC\截图\微信截图_20210413084615.png)



#### 为按钮关联动作方法

按钮的回调通过目标-动作对机制实现。按钮的动作是按钮被按下后需要发送的消息，按钮的目标是接收这条消息的对象。

![](C:\Users\HP\Desktop\OC\截图\微信截图_20210412163546.png)

控件是可以与用户进行交互的视图（与MVC的控制器无关）。

当屏幕所显示的视图包含这类控件时，其中的某个控件可以成为**第一响应对象**（first responder）。拥有第一响应对象状态的控件，可以处理来自键盘的文字输入及摇动事件。

当用户和某个控件产生交互，并且成为第一响应对象时，这个控件就会收到becomeFirstResponder消息。

成为第一响应对象的对象能够接收来自键盘的输入和摇动事件，并且会保持这个状态，直到另一个UIControl对象成为第一响应对象，或者是自己收到resignFirstResponder消息。



#### 为UITableView对象提供数据

作为视图对象，UITableView对象不包含任何实际的数据，而是需要依赖另外一个对象来作为其数据源。UITableView的数据源会告诉表格视图显示什么内容。

被设置为UITableView的数据源的对象所属的类需要遵循UITableDataSource协议。

UITableViewDataSource协议声明了两个必需方法。UITableView的数据源至少要提供以下两类数据：

1、根据指定的表格段索引给出相应的表格段所包含的行数（tableView：numberOfRowsInSection：）

![](C:\Users\HP\Desktop\OC\截图\微信截图_20210412165037.png)

2、根据指定的表格段索引和行索引给出相应的UITableViewCell对象（tableView：cellForRowAtIndexPath：）

![](C:\Users\HP\Desktop\OC\截图\微信截图_20210412165117.png)



#### 保存并加载数组

当Cocoa Touch应用退出运行，或者进入后台运行状态时，其委托对象会收到UIApplicationDelegate协议中的某个特定消息—applicationDidEnterbackgroud:

应用只有在后台运行或者正常关闭的情况下才会保存并重新加载数据。如果从Xcode中关闭应用，数据则可能不会被保存。



#### main（）的作用

![](C:\Users\HP\Desktop\OC\截图\微信截图_20210412170229.png)



## init

NSObject类有一个名为init的方法。initial的示例代码如下：

向新创建的对象发送init消息，它就会初始化其下的实例变量。也就是说alloc负责分配对象空间，init负责初始化对象。

init是实例方法，返回的是初始化之后的对象的地址。



#### 编写init方法

NSObject定义的init方法会将所有的实例变量初始化为0或者nil。

有时候，某些类的实例需要将实例变量初始化为非0的值。

此时可以重写init方法，覆盖NSObject方法；

```
- (instancetype)init;
```

你编写的或是覆盖的任何初始化方法都应该返回instancetype类型的值。



#### 使用并检查父类的初始化方法

苹果公司建议：在自定义init方法时，需要检查父类的初始化方法的返回值，确定不是nil并且有效。如果对象不存在，就没必要执行自定义的初始化代码。



#### 带实参的init方法

initWithxxx：

重写init时可以调用initWithxxx：方法；



#### 在init中使用存取方法

不使用存取方法：

```objective-c
_productName=@"xxx";
```

使用存取方法

```objective-c
[self setProducatName:@"xxx"];
```



#### 多个初始化方法

创建子类时，通常只需要初始化新的实例变量。此外，也需要调用父类的初始化方法，初始化父类的实例变量。

多个初始化串联—一个方法调用另一个方法。

指定初始化方法扮演的是单一入口的角色。任何类都有且只有一个指定初始化方法。如果某个类还有其他初始化方法，那么这些方法应该直接或者间接地调用指定初始化方法！

编写初始化方法时，应该遵循下列原则：

1、其他初始化方法应该直接或者间接地调用指定初始化方法；

2、指定初始化方法应该先调用父类的指定初始化方法，然后再对自己特有的实例变量初始化；

3、如果某个类的指定初始化方法和父类方法的方法名不同，就必须覆盖父类的指定初始化方法，并调用新的指定初始化方法；

4、如果某个类有多个初始化方法，就应该在相应的头文件中明确地注明哪个方法是指定初始化方法；



## 再谈属性

#### 再谈属性的特性

- **存取类型**

  任何一个属性可以声明为readwrite或readonly，默认为readwrite。

  readwrite：程序应该自动创建存方法和取方法；

  readonly：无存方法；

- **生命周期类型**

  生命周期类型的特性包括：unsafe_unretained、assign、strong、weak、copy，这些特性决定了存方法如何处理与其相关的内存管理问题。

  assign是默认的也是最简单的：存方法会将传入的值直接赋值给实例变量；可以使用assign特性来保存非对象类型的实例变量，对于非对象类型的实例变量来说，默认是使用assign特性的。

  strong特性：要求保留传入的对象，并放弃原有对象；凡是指向对象的实例变量，通常都应该使用strong特性。

  weak特性：要求不保留传入的对象（不强调拥有权）。如果该对象被释放，那么相应的实例变量就会被自动赋为nil。这么做可以避免产生**悬空指针**。悬空指针指向的是不再存在的对象，向悬空指针发送消息通常会导致程序崩溃。相应的存方法会将传入的对象直接赋给实例变量。

  unsafe_unretained特性和weak特性类似，要求不保留传入的对象。然而，如果该对象被释放，那么相应的实例变量不会被自动赋为nil。

  copy要求**拷贝传入的对象**，并且将新对象赋给实例变量。

- **copy**

  如果set方法传入的对象是不可修改的，对不可修改的对象进行复制，好像是在做无用功。NSObject的copy方法其实仅仅是调用copyWithZone：并将nil作为实参传入。不可修改的类通常会覆盖copyWithZone：方法，以优化拷贝过程。

  有些类会有两个版本：一个是可修改的，另一个是不可修改的。无论是哪个版本，copy方法都会返回不可修改的版本。

  如果要拷贝出可修改对象，就要使用mutableCopy方法；

- **再谈对象拷贝**

  大多数不是来自苹果公司的OC类并没有实现copyWithZone：方法。

  copyWithZone：方法以及mutableCopyWithZone：方法分别在NSCopying与NSMutableCopying协议中进行了声明。这两个协议，大部分Foudation框架的类都至少符合一个。

  如果自定义的类希望拥有copy特性，就要确保他们符合NSCopying协议。

- **atomic与nonatomic**

  atomic/nonatomic特性属于相对高级的多线程编程范畴。

  调用通过属性机制自动生成的存方法时，如果相关的属性带有nonatomic特性，那么调用的速度会快一点。

  属性默认是atomic特性！



#### 实现存取方法

编译器会默认为你声明的所有属性合成存取方法。

然而，有时候你需要使用存取方法来处理一些特殊逻辑。这种情况下，就需要自己实现存取方法。

两种需要手动实现存取方法的情况：

1、修改实例变量时，需要更新app的用户界面；

2、修改实例变量时，需要更新一些缓存信息；

**如果你声明了一个属性，并且手动实现存取方法，编译器就不会合成实例变量。**

但如果你需要实例变量（通常都需要）就必须自己创建，创建的方法是在类的实现文件中添加@synthesize指令。

![](C:\Users\HP\Desktop\OC\截图\微信截图_20210414080953.png)

@synthesize指令会告诉编译器有一个叫做_mushroom的实例变量，如果它不存在就要将他创建出来。

声明一个只读属性时，编译器会自动合成一个取方法和一个实例变量。因此如果手动实现只读属性的取方法，那么编译器也不会合成实例变量，需要手动合成它。





## KVC

KVC（key-value coding）能够让程序通过名称直接存取属性。因为与KVC有关的方法都是在NSObject中定义的，所以凡是继承自NSObject的类都具备KVC功能。

![](C:\Users\HP\Desktop\OC\截图\微信截图_20210414081412.png)

![](C:\Users\HP\Desktop\OC\截图\微信截图_20210414081506.png)

即使没有实现存取方法，使用KVC，其他（对象外部的）方法一样可以存取某个实例变量。这明显违背了对象封装的理念。所谓对象封装是指对象的方法可以公开，但是实例变量应该保持私有。KVC是一个例外。



#### 非对象类型

KVC只对对象有效（**KVC只能用于对象类型的属性/实例变量的存取**），但是有些属性的类型并不是对象。

对于有些不是对象的类型，比如：int、float等。我们需要基于NSNumber来使用KVC存取这些属性/实例变量。

![](C:\Users\HP\Desktop\OC\截图\微信截图_20210414082315.png)

类似地，valueForKey：方法返回的也是一个NSNumber对象。



#### Key路径

对于复杂对象表，可以使用Key路径，让系统帮我们遍历这些关系，将我们想要的**key排成一个长串，以点分隔**。注意顺序！

![](C:\Users\HP\Desktop\OC\截图\微信截图_20210414082710.png)

![](C:\Users\HP\Desktop\OC\截图\微信截图_20210414082740.png)



## KVO

KVO（key-value observing）键-值观察是指当指定的对象的属性被修改时，允许对象接收通知的机制。

总的来说，就是告诉一个对象，“我想要观察你的xx属性，如果它发生了变化，就通知我”。那么当setxx：方法被调用时，被观察的对象就会发送消息给你：“你好，我的xx属性有一个新值了”。

观察对象的属性时，要指定观察属性的名称。同时还可以指定一些其他的东西，例如你可以告诉对象，当属性发生变化时，将属性的新/旧值发送给我。



#### 在KVO中使用context

注意，当在代码中将某个对象注册为观察者时，你需要传递指针作为context。当接收变化的通知时，context会随通知一起发送给观察者。



#### 显式触发通知

如果使用存取方法来设置属性，那么系统会自动通知观察者。但如果不使用存取方法修改属性，这时可以通过willChangeValueForKey：和didChangeValueForKey：方法通知系统某个属性的值即将/已经发生变化。

![](C:\Users\HP\Desktop\OC\截图\微信截图_20210414084806.png)



#### 独立的属性

如果想观察_lastTimeString，此时会发现观察者并没有正确地收到通知，因为系统不知道lastTime改变时，lastTimeString也会发生变化。

为了修复这个问题，你可以告诉系统lastTime会影响lastTimeString。可以通过实现一个类方法来做这项工作。

![](C:\Users\HP\Desktop\OC\截图\微信截图_20210414090552.png)





## 范畴

通过使用范畴（Category），程序员可以为任何已有的类添加方法

![](C:\Users\HP\Desktop\OC\截图\微信截图_20210414091120.png)



## OC运行时

运行时（runtime）这个术语有多重的意思。到目前为止，我们用它形容应用在用户电脑中运行的一段时间。运行时可以和编译时进行对比，编译时是在程序运行之前，指还在使用Xcode构建程序的一段时间。

OC运行时是OS X以及IOS系统执行OC代码的一部分。它还负责**动态地追踪记录哪些类存在，这些类定义了哪些方法，以及查看消息是否恰当地在对象之间传递**。



#### 内省

内省（introspection）是OC运行时的一个特性：它能够让对象在程序运行的时候回答关于自身的问题。

例如NSObject有一个实例方法：

（BOOL）respondsToSelector：（SEL）aSelector；

如果对象实现了该选择器名字的方法，就会返回YES；如果没有实现，就返回NO；



#### 动态查找并执行方法

一个运行中的Objective-C程序包含了大量的对象，对象之间彼此发送消息。对象发送消息的时候，它就会开始搜索要执行的方法。通常会从接收者的isa指针指向的类开始进行搜索，然后根据继承层级向上搜索，直到找到需要的方法。

动态查找并执行方法构成了Objective-C消息发送机制的基础。它也是Objective-C运行时的另一大特性。



#### 类以及继承层级的管理

OC运行时不仅负责记录正在使用哪些类，还负责记录那些包含到程序中的库以及框架使用的类。

可以用下列方式获取某个类的类名、继承层级、方法列表：

![](C:\Users\HP\Desktop\OC\截图\微信截图_20210414113748.png)



#### KVO的工作原理

如果对象使用存取器，被观察的对象可以自动通知属性中的变化。

运行时，如果向某个对象发送addObserver：forKeyPath：options：context：消息，那么这个方法可以：

1、决定被观察对象的类，并使用objc_allocateClassPair()函数给这个类定义一个新的子类；

2、改变对象的isa指针，让他指向新的子类（高效改变对象的类型）；

3、覆盖被观察对象的存取器，发送KVO消息

![](C:\Users\HP\Desktop\OC\截图\微信截图_20210414120131.png)

注意：运行时函数主要是苹果公司的工程师在编写API时使用的，并不适合用于编写日常应用。